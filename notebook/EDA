{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9ec86bbb",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# # **EDA датасета по сердечно-сосудистым заболеваниям**\n",
    "# \n",
    "# ## **Введение**\n",
    "# \n",
    "# EDA датасета по сердечно-сосудистым заболеваниям проводится с целью оценки структуры, целостности и полноты данных, а также обнаружения выбросов и аномалий.\n",
    "\n",
    "# ## **Подготовка к работе**\n",
    "# Импортируем необходимые для обработки данных библиотеки и загружаем данные"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e656bfc9",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "\n",
    "file_id = \"19T-Gm5Dovnae7htHjJP2gUt3Tyl6NPp2\"  # ID файла на Google Drive\n",
    "file_url = f\"https://drive.google.com/uc?id={file_id}\"\n",
    "\n",
    "try:\n",
    "    df = pd.read_csv(file_url, delimiter=';')\n",
    "    print(\"Данные загружены\")\n",
    "except Exception as e:\n",
    "    print(\"Произошла ошибка при загрузке файла:\", e)\n",
    "    raise   \n",
    "\n",
    "print(f\"Размер датасета: {df.shape}\")\n",
    "print(f\"Количество строк: {df.shape[0]}\")\n",
    "print(f\"Количество столбцов: {df.shape[1]}\")\n",
    "print(\"\\n\")\n",
    "\n",
    "print(\"Выведем первые 5 строк датасета\")\n",
    "print(df.head())\n",
    "print(\"\\n\")\n",
    "\n",
    "print(\"Узнаем информацию о типах данных\")\n",
    "print(df.info())\n",
    "print(\"\\n\")\n",
    "\n",
    "\n",
    "# ## **Оценка полноты данных (completeness)**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c4013781",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "print('Полнота данных по колонкам')\n",
    "# Создаем таблицу с результатами\n",
    "results = []\n",
    "for column in df.columns:\n",
    "    total_rows = len(df)\n",
    "    missing_count = df[column].isna().sum()\n",
    "    filled_count = total_rows - missing_count\n",
    "    completeness = (filled_count / total_rows) * 100\n",
    "\n",
    "    results.append({\n",
    "        'Колонка': column,\n",
    "        'Заполнено (%)': round(completeness, 1),\n",
    "        'Пропусков': missing_count,\n",
    "        'Заполнено строк': filled_count\n",
    "    })\n",
    "\n",
    "# Создаем DataFrame и сортируем по полноте\n",
    "completeness_df = pd.DataFrame(results)\n",
    "completeness_df = completeness_df.sort_values('Заполнено (%)')\n",
    "\n",
    "# Показываем результаты\n",
    "print(completeness_df.to_string(index=False))\n",
    "print()\n",
    "\n",
    "# Статистика по качеству данных\n",
    "perfect_columns = len(completeness_df[completeness_df['Заполнено (%)'] == 100])\n",
    "good_columns = len(completeness_df[completeness_df['Заполнено (%)'] >= 90])\n",
    "bad_columns = len(completeness_df[completeness_df['Заполнено (%)'] < 80])\n",
    "empty_columns = len(completeness_df[completeness_df['Заполнено (%)'] == 0])\n",
    "\n",
    "print(f\"Колонок полностью заполнено (100%): {perfect_columns}\")\n",
    "print(f\"Колонок хорошо заполнено (>=90%): {good_columns}\")\n",
    "print(f\"Колонок плохо заполнено (<80%): {bad_columns}\")\n",
    "print(f\"Колонок полностью пустых (0%): {empty_columns}\")\n",
    "\n",
    "# При необходимости показываем проблемные колонки\n",
    "problem_columns = completeness_df[completeness_df['Заполнено (%)'] < 80]\n",
    "if len(problem_columns) > 0:\n",
    "    print(f\"\\n Проблемные колонки (заполнено меньше 80%):\")\n",
    "    for _, row in problem_columns.iterrows():\n",
    "        print(f\"   - {row['Колонка']}: {row['Заполнено (%)']}%\")\n",
    "\n",
    "# Визуализация\n",
    "print(\"График\")\n",
    "plt.figure(figsize=(10, 8))\n",
    "\n",
    "# График полноты по колонкам\n",
    "plt.barh(completeness_df['Колонка'], completeness_df['Заполнено (%)'])\n",
    "plt.xlabel('Процент заполненности')\n",
    "plt.title('completeness относительно колонок')\n",
    "plt.axvline(x=80, color='red', linestyle='--', label='Порог 80%')\n",
    "plt.legend()\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Рекомендации\n",
    "print(\"Рекомендации\")\n",
    "if bad_columns == 0:\n",
    "    print(\"Отличное качество данных! Все колонки заполнены хорошо.\")\n",
    "elif bad_columns < 5:\n",
    "    print(\"Хорошее качество данных. Несколько колонок требуют внимания.\")\n",
    "else:\n",
    "    print(\"Есть проблемы с качеством данных. Много колонок с пропусками.\")\n",
    "\n",
    "\n",
    "# Таким образом, в представленном датасете хорошее качество данных, отличающихся высокой полнотой, за исключением колонки Alcohol Intake\n",
    "\n",
    "# ## **Оценка уникальности данных**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fbed57cf",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "# Проверка уникальности строк\n",
    "duplicate_count = df.duplicated().sum()\n",
    "uniqueness_score = 1 - (duplicate_count / len(df))\n",
    "\n",
    "print(\"Оценка уникальности строк\")\n",
    "print(f\"Всего строк в датасете: {len(df)}\")\n",
    "print(f\"Найдено дубликатов: {duplicate_count}\")\n",
    "print(f\"Оценка уникальности: {uniqueness_score:.3f}\")\n",
    "\n",
    "# Проверка\n",
    "if uniqueness_score == 1.0:\n",
    "    print(\"Все хорошо: Дубликатов нет\")\n",
    "else:\n",
    "    print(\"Проблема: Есть дубликаты\")\n",
    "\n",
    "\n",
    "# Все строки в датасете уникальны\n",
    "\n",
    "# ## **Поиск выбросов методом IQR**\n",
    "\n",
    "# Проводим статистический анализ числовых данных с целью выявления выбросов"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "78bca3da",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "numerical_columns = df.select_dtypes(include=[np.number]).columns\n",
    "\n",
    "outliers_summary = {}\n",
    "\n",
    "for col in numerical_columns:\n",
    "    Q1 = df[col].quantile(0.25)\n",
    "    Q3 = df[col].quantile(0.75)\n",
    "    IQR = Q3 - Q1\n",
    "\n",
    "    lower_bound = Q1 - 1.5 * IQR\n",
    "    upper_bound = Q3 + 1.5 * IQR\n",
    "\n",
    "    outliers = df[(df[col] < lower_bound) | (df[col] > upper_bound)]\n",
    "    outliers_count = len(outliers)\n",
    "    outliers_percentage = (outliers_count / len(df)) * 100\n",
    "\n",
    "    outliers_summary[col] = {\n",
    "        'outliers_count': outliers_count,\n",
    "        'outliers_percentage': outliers_percentage,\n",
    "        'lower_bound': lower_bound,\n",
    "        'upper_bound': upper_bound\n",
    "    }\n",
    "\n",
    "    print(f\"\\n--- {col} ---\")\n",
    "    print(f\"Выбросов: {outliers_count} ({outliers_percentage:.2f}%)\")\n",
    "    print(f\"Границы выбросов: [{lower_bound:.2f}, {upper_bound:.2f}]\")\n",
    "\n",
    "# Визуализация выбросов\n",
    "if len(numerical_columns) > 0:\n",
    "    print(\"Визуализация выбросов\")\n",
    "\n",
    "    # Ограничим количество графиков для читаемости\n",
    "    cols_to_plot = numerical_columns[:6]  # Первые 6 числовых колонок\n",
    "\n",
    "    fig, axes = plt.subplots(2, 3, figsize=(18, 10))\n",
    "    axes = axes.ravel()\n",
    "\n",
    "    for i, col in enumerate(cols_to_plot):\n",
    "        if i < len(axes):\n",
    "            df.boxplot(column=col, ax=axes[i])\n",
    "            axes[i].set_title(f'Выбросы: {col}')\n",
    "\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "\n",
    "\n",
    "# Теперь проведем анализ только категориальных колонок"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "51920e1b",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "categorical_cols = df.select_dtypes(include=['object', 'category']).columns\n",
    "print(f\"Категориальных колонок: {len(categorical_cols)}\")\n",
    "\n",
    "for col in categorical_cols:\n",
    "    print(f\"\\n{col}:\")\n",
    "    print(f\"   Всего уникальных значений: {df[col].nunique()}\")\n",
    "    print(f\"   Пропущенные значения: {df[col].isna().sum()}\")\n",
    "\n",
    "    value_counts = df[col].value_counts()\n",
    "    print(\"Возможные значения:\")\n",
    "    for i, (value, count) in enumerate(value_counts.head().items(), 1):\n",
    "        print(f\"   {i}. {value}: {count} записей\")\n",
    "\n",
    "    # Визуализация для колонок с малым числом уникальных значений\n",
    "    if df[col].nunique() <= 10:\n",
    "        plt.figure(figsize=(8, 4))\n",
    "        value_counts.head(10).plot(kind='bar')\n",
    "        plt.title(f'Распределение: {col}')\n",
    "        plt.xticks(rotation=45)\n",
    "        plt.show()\n",
    "\n",
    "print(f\"\\nАнализ завершен! Обработано {len(categorical_cols)} категориальных колонок.\")\n",
    "\n",
    "\n",
    "# ## **Выводы**\n",
    "# \n",
    "# ### Структура\n",
    "# Датасет содержит 16 признаков и 1000 строк\n",
    "# Типы данных корректны для всех колонок\n",
    "# \n",
    "# ### Полнота данных\n",
    "# Все данные в датасете уникальны, а также имеют хорошее качество, т.к. практически все колонки полноценны.\n",
    "# Однако колонка Alcohol Intake заполнена только на 66.0%. Соответсвтенно, для адекватного анализа данных в дальнейшем, чтобы сохранить объем выборки, необходимо удалить данный столбец.\n",
    "# \n",
    "# ### Выбросы\n",
    "# В числовых данных выбросов не обнаружено\n",
    "# Из категориальных данных проблемы выявлены только в Alcohol Intake"
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "cell_metadata_filter": "-all",
   "encoding": "# coding: utf-8",
   "executable": "/usr/bin/env python",
   "main_language": "python",
   "notebook_metadata_filter": "-all"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
